<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Sydney Grit – Full Rebuild</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
/* --- GLOBAL PAGE STYLING --- */
body {
    margin: 0;
    background: #0c0f12;
    overflow: hidden;
    user-select: none;
    font-family: Arial, sans-serif;
}

canvas {
    display: block;
    margin: 0 auto;
    background: #050607;
}

/* --- HUD TEXT + BARS --- */
#hud {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    z-index: 10;
    font-size: 14px;
    line-height: 1.5;
}

.bar {
    width: 160px;
    height: 10px;
    background: #333;
    margin-bottom: 5px;
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid #000;
}

.bar-inner {
    height: 100%;
    width: 100%;
    background: #55ff55;
    transition: width 0.2s;
}
</style>
</head>
<body>

<!-- ========================= -->
<!-- HUD SYSTEM -->
<!-- ========================= -->
<div id="hud">
    <div>Hunger</div><div class="bar"><div id="bar-hunger" class="bar-inner"></div></div>
    <div>Warmth</div><div class="bar"><div id="bar-warmth" class="bar-inner"></div></div>
    <div>Hope</div><div class="bar"><div id="bar-hope" class="bar-inner"></div></div>
    <div>Vice</div><div class="bar"><div id="bar-vice" class="bar-inner"></div></div>

    <div style="margin-top:10px;">
        Cash: <span id="cash">0</span><br>
        Heat: <span id="heat">0</span><br>
        Time Alive: <span id="timer">0</span>s<br>
        Suburb: <span id="suburb">CBD</span>
    </div>
</div>

<!-- ========================= -->
<!-- GAME CANVAS -->
<!-- ========================= -->
<canvas id="game"></canvas>

<script>
/* ============================================================
   PART 1/3 – CORE ENGINE, STRUCTURE, RENDERER, SYSTEM SETUP
   ============================================================ */

/* ---------------------------------------
   CANVAS + CONTEXT SETUP
--------------------------------------- */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.onresize = resizeCanvas;

/* ---------------------------------------
   GAME STATE
--------------------------------------- */
const state = {
    hunger: 100,
    warmth: 100,
    hope: 100,
    vice: 0,

    cash: 0,
    heat: 0,
    timeAlive: 0,

    dogHunger: 100,
    dogLoyalty: 100,

    suburb: "CBD",
    timeOfDay: 12,

    entities: [],
    events: [],
    particles: [],

    lastFrame: performance.now(),
};

/* ---------------------------------------
   INPUT HANDLER
--------------------------------------- */
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

/* ---------------------------------------
   UTILITIES
--------------------------------------- */
function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
}

function rand(a, b) {
    return Math.random() * (b - a) + a;
}

function chance(p) {
    return Math.random() < p;
}

/* ---------------------------------------
   SPRITE BASE64 (HYBRID PIXEL SILHOUETTES)
--------------------------------------- */
const spritePlayer = new Image();
spritePlayer.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAP0lEQVRYhe3OQQ0AAAgDINc/9K3hCEqMwkQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4GQ+DAB4tiTmrAAAAAElFTkSuQmCC";

const spriteDog = new Image();
spriteDog.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAWCAYAAAD5nd/tAAAAPUlEQVRIie3SMQ0AIAwDwYA9/6Wn0hEIjzDk3SCe8x2VIQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8Br8NAgABNEMY0QAAAABJRU5ErkJggg==";

const spriteNPC = new Image();
spriteNPC.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAPUlEQVRIiWNgGAWjgH3g////MpwYGBiYDBgwGP5z/P///w8GhgYGBtBpgBIMGEAFBgYGhgYGBtC2ICACABmQaL5GsyhWAAAAAElFTkSuQmCC";

const spriteIbis = new Image();
spriteIbis.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAXCAYAAACh+o6PAAAAOklEQVRIie3SQQ0AIAwDsYG9/6VnEECjMCHfYyZf68hIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8G78FBAAAz5FlAQQAAAABJRU5ErkJggg==";

const spriteCop = new Image();
spriteCop.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAhCAYAAADp6C6iAAAARklEQVRIiWNgGAWjgP///8M7MDDw////BwYmBiYGoQYmBgYGH7H8///BgbGBiYGoQZmBgYGLzPwP///x8GhgYGhgYGBgBjOx0lczHxLAAAAABJRU5ErkJggg==";

/* ---------------------------------------
   ENTITY SYSTEM BASE CLASS
--------------------------------------- */
class Entity {
    constructor(x, y, w, h, sprite = null) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.sprite = sprite;
        this.dead = false;
    }
    update(dt) {}
    draw(ctx) {
        if (this.sprite) {
            ctx.drawImage(this.sprite, this.x, this.y, this.w, this.h);
        } else {
            ctx.fillStyle = "white";
            ctx.fillRect(this.x, this.y, this.w, this.h);
        }
    }
}

/* ---------------------------------------
   PLAYER
--------------------------------------- */
class Player extends Entity {
    constructor() {
        super(canvas.width/2, canvas.height - 200, 60, 60, spritePlayer);
        this.speed = 220;
    }
    update(dt) {
        if (keys["ArrowLeft"])  this.x -= this.speed * dt;
        if (keys["ArrowRight"]) this.x += this.speed * dt;
        if (keys["ArrowUp"])    this.y -= this.speed * dt;
        if (keys["ArrowDown"])  this.y += this.speed * dt;

        // Boundaries
        this.x = clamp(this.x, 0, canvas.width - this.w);
        this.y = clamp(this.y, 0, canvas.height - 200);
    }
}

/* ---------------------------------------
   DOG (FOLLOWER)
--------------------------------------- */
class Dog extends Entity {
    constructor(player) {
        super(player.x - 80, player.y, 40, 40, spriteDog);
        this.player = player;
    }
    update(dt) {
        // Follow logic
        this.x += (this.player.x - this.x) * 0.05;
        this.y += (this.player.y - this.y) * 0.05;
    }
}

/* ---------------------------------------
   NPC BASE
--------------------------------------- */
class NPC extends Entity {
    constructor(x, y) {
        super(x, y, 50, 50, spriteNPC);
        this.speed = rand(40, 70);
    }
    update(dt) {
        this.x -= this.speed * dt;
        if (this.x < -200) this.dead = true;
    }
}

/* ---------------------------------------
   IBIS
--------------------------------------- */
class Ibis extends Entity {
    constructor() {
        super(canvas.width + 60, canvas.height - 210, 50, 40, spriteIbis);
        this.speed = rand(30, 60);
    }
    update(dt) {
        this.x -= this.speed * dt;
        if (this.x < -100) this.dead = true;
    }
}

/* ---------------------------------------
   POLICE (CHASERS)
--------------------------------------- */
class Cop extends Entity {
    constructor(target) {
        super(canvas.width + 100, target.y, 60, 60, spriteCop);
        this.target = target;
        this.speed = 180;
        this.tripping = false;
        this.tripTimer = 0;
    }
    update(dt) {
        if (!this.tripping) {
            this.x -= this.speed * dt;
            if (chance(0.001)) {
                this.tripping = true;
                this.tripTimer = 0.7; // seconds
            }
        } else {
            this.tripTimer -= dt;
            if (this.tripTimer <= 0) this.dead = true;
        }

        // Collision with player → punish
        if (Math.abs(this.x - this.target.x) < 40 &&
            Math.abs(this.y - this.target.y) < 40) {
            state.hope -= 8;
            state.heat += 10;
            this.dead = true;
        }
    }
}

/* ---------------------------------------
   ADD INITIAL ENTITIES (PLAYER + DOG)
--------------------------------------- */
const player = new Player();
const dog = new Dog(player);
state.entities.push(player, dog);

/* ============================================================
   PART 2/3 – WORLD SYSTEM, PARALLAX, SUBURBS, WEATHER, DAY/NIGHT
   ============================================================ */

/* ---------------------------------------
   WORLD BACKGROUND LAYERS (PARALLAX)
--------------------------------------- */

const bgLayers = {
    sky:    { color: "#1a1d22", speed: 0 },
    far:    { offset: 0, speed: 10, img: null },
    mid:    { offset: 0, speed: 40, img: null },
    near:   { offset: 0, speed: 80, img: null },
    street: { offset: 0, speed: 140, img: null }
};

/* Base64 simple skyline layers (abstract silhouettes) */
bgLayers.far.img = new Image();
bgLayers.far.img.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAABkCAYAAABZECYIAAAAOElEQVR4nO3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwJgeHAAHg0BdXAAAAAElFTkSuQmCC";

bgLayers.mid.img = new Image();
bgLayers.mid.img.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXAAAAA/CAYAAAB2k8WcAAAAN0lEQVR4nO3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEODceQAHYrKTVAAAAAElFTkSuQmCC";

bgLayers.near.img = new Image();
bgLayers.near.img.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWAAAABUCAYAAAA1sr1FAAAAPElEQVR4nO3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEODceQAHYrKTVAAAAAElFTkSuQmCC";

bgLayers.street.img = new Image();
bgLayers.street.img.src =
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYAAAABMCAYAAACvC/P8AAAAO0lEQVR4nO3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEODceQAHYrKTVAAAAAElFTkSuQmCC";

/* ---------------------------------------
   SUBURB DEFINITIONS
--------------------------------------- */
const suburbs = [
    { name: "CBD",         danger: 1, colorTint: "rgba(0,0,0,0.15)" },
    { name: "Kings Cross", danger: 2, colorTint: "rgba(60,0,0,0.20)" },
    { name: "Surry Hills", danger: 1.2, colorTint: "rgba(0,30,0,0.15)" },
    { name: "Chinatown",   danger: 1.5, colorTint: "rgba(40,40,0,0.20)" },
    { name: "Cabramatta",  danger: 1.7, colorTint: "rgba(30,0,30,0.20)" },
    { name: "Parramatta",  danger: 1.1, colorTint: "rgba(0,0,50,0.15)" },
    { name: "Mt Druitt",   danger: 3, colorTint: "rgba(50,0,50,0.25)" }
];

let currentSuburbIndex = 0;

/* Scroll counter to trigger suburb transitions */
let worldScroll = 0;
const suburbLength = 6000; // pixels to scroll before shifting suburb

/* ---------------------------------------
   WEATHER SYSTEM
--------------------------------------- */
const weather = {
    type: "clear",
    timer: 0,
    particles: []
};

function updateWeather(dt) {
    weather.timer -= dt;
    if (weather.timer <= 0) {
        const roll = Math.random();
        if (roll < 0.6) weather.type = "clear";
        else if (roll < 0.8) weather.type = "rain";
        else weather.type = "storm";

        weather.timer = rand(20, 60); // seconds
    }

    // Rain particles
    if (weather.type === "rain" || weather.type === "storm") {
        for (let i = 0; i < 10; i++) {
            weather.particles.push({
                x: rand(0, canvas.width),
                y: -10,
                speed: rand(200, 400)
            });
        }
    }

    weather.particles.forEach(p => {
        p.y += p.speed * dt;
        if (p.y > canvas.height) p.dead = true;
    });
    weather.particles = weather.particles.filter(p => !p.dead);
}

/* ---------------------------------------
   DAY / NIGHT CYCLE
--------------------------------------- */
function updateTimeOfDay(dt) {
    state.timeOfDay += dt * 0.1; // slow cycle

    if (state.timeOfDay >= 24) state.timeOfDay -= 24;
}

function applyTimeTint() {
    // Night darkness
    let tint = 0;
    if (state.timeOfDay >= 20 || state.timeOfDay <= 5) tint = 0.5; // dark night
    else if (state.timeOfDay >= 17 && state.timeOfDay < 20) tint = 0.3; // dusk
    else if (state.timeOfDay >= 5 && state.timeOfDay < 8)  tint = 0.2; // dawn

    ctx.fillStyle = `rgba(0,0,0,${tint})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

/* ---------------------------------------
   PARALLAX RENDERING
--------------------------------------- */
function renderParallax(dt) {
    ctx.fillStyle = bgLayers.sky.color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Move layers based on player movement
    let speedFactor = (keys["ArrowLeft"] ? -1 : keys["ArrowRight"] ? 1 : 0);

    for (const key in bgLayers) {
        const layer = bgLayers[key];
        if (layer.speed > 0) {
            layer.offset += layer.speed * dt * speedFactor;
            if (layer.offset < -canvas.width) layer.offset += canvas.width;
            if (layer.offset > canvas.width) layer.offset -= canvas.width;

            // Draw twice for seamless scroll
            ctx.drawImage(layer.img, layer.offset, canvas.height - layer.img.height - 180);
            ctx.drawImage(layer.img, layer.offset + canvas.width, canvas.height - layer.img.height - 180);
        }
    }

    // Street layer
    ctx.drawImage(bgLayers.street.img, 0, canvas.height - 160, canvas.width, 160);
}

/* ---------------------------------------
   SUBURB TRANSITIONS
--------------------------------------- */
function updateSuburb(dt) {
    // Scroll accumulates as player moves horizontally
    if (keys["ArrowRight"]) worldScroll += dt * 200;
    if (keys["ArrowLeft"]) worldScroll -= dt * 200;

    if (Math.abs(worldScroll) > suburbLength) {
        worldScroll = 0;
        currentSuburbIndex = (currentSuburbIndex + 1) % suburbs.length;
        state.suburb = suburbs[currentSuburbIndex].name;
    }
}

/* ---------------------------------------
   HUD UPDATE
--------------------------------------- */
function updateHUD() {
    document.getElementById("bar-hunger").style.width = state.hunger + "%";
    document.getElementById("bar-warmth").style.width = state.warmth + "%";
    document.getElementById("bar-hope").style.width = state.hope + "%";
    document.getElementById("bar-vice").style.width = state.vice + "%";

    document.getElementById("cash").textContent = Math.floor(state.cash);
    document.getElementById("heat").textContent = Math.floor(state.heat);
    document.getElementById("timer").textContent = Math.floor(state.timeAlive);
    document.getElementById("suburb").textContent = state.suburb;
}

/* ============================================================
   PART 3/3 – NPC AI, EVENTS, DOG, POLICE, SURVIVAL, LOOP
   ============================================================ */

let npcSpawnTimer = 0;
let ibisSpawnTimer = 0;
let copSpawnTimer = 0;

function spawnNPC() {
    state.entities.push(new NPC(
        canvas.width + 50,
        canvas.height - 200 - rand(0, 100)
    ));
}

function spawnIbis() {
    state.entities.push(new Ibis());
}

function spawnCop() {
    if (state.heat < 20) return;
    state.entities.push(new Cop(player));
}

function updateDog(dt) {
    state.dogHunger -= dt * 1;
    state.dogHunger = clamp(state.dogHunger, 0, 100);

    if (state.dogHunger < 20) state.dogLoyalty -= dt * 5;

    if (state.dogLoyalty <= 0) {
        state.entities = state.entities.filter(e => !(e instanceof Dog));
    }
}

function handleEncounter(npc) {
    const roll = Math.random();

    if (roll < 0.25) {
        state.cash += rand(1, 5);
        state.hope += 2;
    } else if (roll < 0.5) {
        state.heat += 5;
        state.hope -= 3;
    } else if (roll < 0.75) {
        state.vice = clamp(state.vice - 5, 0, 100);
        state.hope += 1;
    } else {
        state.hope -= 5;
    }
}

function updatePolice(dt) {
    state.heat -= dt * 0.5;
    state.heat = clamp(state.heat, 0, 100);

    if (state.heat > 40 && copSpawnTimer <= 0) {
        spawnCop();
        copSpawnTimer = rand(5, 10);
    }
}

function updateSurvival(dt) {
    state.hunger -= dt * 2;
    if (state.hunger <= 0) state.hope -= dt * 15;

    let warmthRate = 0.7;
    if (weather.type === "storm") warmthRate = 2.0;

    const hour = state.timeOfDay;
    if (hour >= 20 || hour <= 6) warmthRate += 0.5;

    state.warmth -= dt * warmthRate;

    state.vice += dt * 0.8;

    if (state.hunger < 30) state.hope -= dt * 3;
    if (state.warmth < 30) state.hope -= dt * 3;
    if (state.vice > 80) state.hope -= dt * 2;

    state.hunger = clamp(state.hunger, 0, 100);
    state.warmth = clamp(state.warmth, 0, 100);
    state.hope = clamp(state.hope, 0, 100);
    state.vice = clamp(state.vice, 0, 100);
}

function checkDeath() {
    return (
        state.hope <= 0 ||
        state.warmth <= 0 ||
        state.hunger <= 0
    );
}

function renderDeathScreen() {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#ff4444";
    ctx.font = "48px Arial";
    ctx.fillText("GAME OVER", canvas.width/2 - 120, canvas.height/2 - 40);

    ctx.fillStyle = "white";
    ctx.font = "24px Arial";
    ctx.fillText(`Time alive: ${Math.floor(state.timeAlive)}s`, canvas.width/2 - 90, canvas.height/2 + 10);
}

function updateEntities(dt) {
    for (const e of state.entities) e.update(dt);

    state.entities.forEach(e => {
        if (e instanceof NPC) {
            if (
                Math.abs(e.x - player.x) < 40 &&
                Math.abs(e.y - player.y) < 40
            ) {
                handleEncounter(e);
                e.dead = true;
            }
        }
    });

    state.entities = state.entities.filter(e => !e.dead);
}

function updateSpawns(dt) {
    npcSpawnTimer -= dt;
    ibisSpawnTimer -= dt;
    copSpawnTimer -= dt;

    if (npcSpawnTimer <= 0) {
        spawnNPC();
        npcSpawnTimer = rand(2, 5);
    }

    if (ibisSpawnTimer <= 0) {
        spawnIbis();
        ibisSpawnTimer = rand(6, 12);
    }
}

function renderEntities() {
    for (const e of state.entities) e.draw(ctx);
}

function renderWeather() {
    if (weather.type === "rain" || weather.type === "storm") {
        ctx.strokeStyle = "rgba(180,180,255,0.5)";
        ctx.lineWidth = 2;
        weather.particles.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + 3, p.y + 10);
            ctx.stroke();
        });
    }
}

function gameLoop(ts) {
    const dt = (ts - state.lastFrame) / 1000;
    state.lastFrame = ts;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    renderParallax(dt);

    updateSpawns(dt);
    updateEntities(dt);
    updateWeather(dt);
    updatePolice(dt);
    updateDog(dt);
    updateSurvival(dt);
    updateSuburb(dt);
    updateTimeOfDay(dt);
    updateHUD();

    renderEntities();
    renderWeather();
    applyTimeTint();

    state.timeAlive += dt;

    if (checkDeath()) {
        renderDeathScreen();
        return;
    }

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>

</body>
</html>
